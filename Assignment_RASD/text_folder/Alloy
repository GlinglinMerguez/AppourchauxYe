module internshipPlatformMatching

// Abstract signatures for users
abstract sig User {
    email: one String,
    password: one String
}

// User types
sig Student extends User {
    skills: set String,
    preferences: set String,
    applications: set Application
}

sig Company extends User {
    offers: set InternshipOffer
}

// Internship offers
sig InternshipOffer {
    company: one Company,
    title: one String,
    description: one String,
    requiredSkills: set String,
    preferredSkills: set String,
    status: one OfferStatus
}

// Offer status
enum OfferStatus { ACTIVE, CLOSED, COMPLETED }

// Applications
sig Application {
    student: one Student,
    offer: one InternshipOffer,
    status: one ApplicationStatus
}

// Application status
enum ApplicationStatus { PENDING, SHORTLISTED, ACCEPTED, REJECTED }

// Matching rules
fun matchingScore(s: Student, o: InternshipOffer): Int {
    let studentSkills = s.skills,
        offerSkills = o.requiredSkills + o.preferredSkills |
    # (studentSkills & offerSkills) // Number of matching skills
}

// Matching predicate
pred matchOffers {
    all s: Student, o: InternshipOffer |
        o.status = ACTIVE and
        some (s.skills & o.requiredSkills) and
        some (s.skills & o.preferredSkills) implies {
            some a: Application |
                a.student = s and
                a.offer = o and
                a.status = PENDING
        }
}



// Example data for simulation
run {
    // Create example students and offers
    some s1, s2: Student |
        s1.skills = {"Java" + "Python" + "SQL"} and
        s2.skills = {"Python" + "Data Analysis"} and

    some o1, o2: InternshipOffer |
        o1.requiredSkills = {"Python" + "SQL"} and o1.preferredSkills = {"Data Analysis"} and o1.status = ACTIVE and
        o2.requiredSkills = {"Java"} and o2.preferredSkills = {"Machine Learning"} and o2.status = ACTIVE and

    // Match students to offers
    matchOffers
} for 5

